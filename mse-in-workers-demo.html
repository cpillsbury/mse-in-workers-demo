<!DOCTYPE html>
<meta charset="utf-8">
<title>Simple MediaSource-in-Workers Demo</title>
<script src="mse-in-workers-util.js"></script>
<body>
  <button id="start-button" onclick="start_demo_players()">Start demo</button>
  <div style="width: 100%;" id="top_div">Awaiting start</div>
  <div style="width: 100%;">
    <div style="width: 50%; float: left;" id="left_div">
      <br><hr><b>MSE usage on main thread</b>
    </div>
    <div style="margin-left: 50%;" id="right_div">
      <br><hr><b>MSE usage in worker thread (with video element on main thread)</b>
    </div>
  </div>
<script>

const MEDIA_URL = "test-5seconds.webm";
const MEDIA_TYPE = 'video/webm; codecs="vp9"';
// Demo is able to show more effectively the main vs worker difference when buffering tiny chunks at a time.
const APPEND_SIZE = 1024;

const BUSYWAIT_DURATION_MILLISECONDS = 100;

const start_button = document.getElementById("start-button");
start_button.style.backgroundColor = "white";

const main_div = document.getElementById('left_div');
const worker_div = document.getElementById('right_div');
const wait_div = document.getElementById("top_div");
let wait_counter = 0;
let wait_handle;
let pending_ended_count_before_stopping_busywait = 0;

function start_busy_waiting() {
  let wait_start = performance.now();
  wait_counter++;
  wait_div.innerText = "Iteration #" + wait_counter + " of busy-waiting " +
      BUSYWAIT_DURATION_MILLISECONDS + " milliseconds on main thread...";

  while (performance.now() - wait_start < BUSYWAIT_DURATION_MILLISECONDS) {
    /* busy-wait */
  }

  wait_div.innerText += "done";
  wait_handle = setTimeout(start_busy_waiting, 0);
}

function stop_busy_waiting() {
  if (wait_handle != undefined) {
    clearTimeout(wait_handle);
    wait_handle = undefined;
    wait_div.innerText = "All players have ended or errored. Stopped busy-waiting on main thread.";
  }
}

function log(log_div, entry) {
  let span = document.createElement("span");
  span.innerHTML = entry + "<br>";
  log_div.appendChild(span);
}

function increment_pending_ended() {
  if (pending_ended_count_before_stopping_busywait == 0)
    start_busy_waiting();

  pending_ended_count_before_stopping_busywait++;
}

function decrement_pending_ended() {
  pending_ended_count_before_stopping_busywait--;
  if (pending_ended_count_before_stopping_busywait <= 0)
    stop_busy_waiting();
}

function start_mse_buffering_in_worker(log_div, video) {
  const worker = new Worker('demo-worker.js');  // TODO
  // TODO install worker.onerror handler.

  // Note, we could just have the worker initiate fetch and buffering
  // immediately when started, but to help make this demo more reusable
  // without having to hardcode MEDIA_URL and MEDIA_TYPE in the worker code,
  // we provide it with that info via an initial message.

  worker.postMessage({ media_url: MEDIA_URL, media_type: MEDIA_TYPE, append_size: APPEND_SIZE }); // BIG TODO: does this work???

  worker.onmessage = msg => {
    log(log_div, "Received msg from worker: topic=" + msg.topic + ", arg=" + msg.arg);
    switch (msg.data.topic) {
      case 'error':
        // There was an issue in the worker's use of MSE. The video might already be playing.
        // Regardless, help ensure the busy-waiting eventually stops since the demo is malfunctioning.
        decrement_pending_ended();
        break;
      case 'objectUrl':
        video.src = msg.arg;
        break;
// TODO send and handle here an 'info' topic
      default:
        log(log_div, "error: Unrecognized topic in message from worker");
        break;
    }
    return;
  };

// TODO: replace this:
return Promise.resolve();
}

function start_mse_buffering_in_main(log_div, video) {
  let media_source = new MediaSource();
  let object_url = URL.createObjectURL(media_source);
  video.src = object_url;
  return Promise.all([
      // Let playback start when ready.
      video.play(),

      // Meanwhile, begin fetching and appending.
      fetch_and_append_in_chunks(media_source,
        MEDIA_URL,
        MEDIA_TYPE,
        APPEND_SIZE,
        object_url /* sourceopen handler in utility script will revoke this url */,
        logmsg => { log(log_div, logmsg); })
    ]);
}

function start_demo_player(div, use_worker) {
  div.appendChild(document.createElement("hr"));
  const video = document.createElement("video");
  div.appendChild(video);
  video.load();

  const log_div = document.createElement("div");
  div.appendChild(log_div);
  log(log_div, "Starting demo of MSE " +
                   (use_worker ? " usage from worker" :
                                 " usage from main thread"));

  let handled_decrement = false;
  increment_pending_ended();

  if (window.MediaSource == undefined) {
    log(log_div, "Error: MediaSource API is unavailable from main/Window context.");
    decrement_pending_ended();
    return;
  }

  if (use_worker && (!MediaSource.hasOwnProperty("canConstructInDedicatedWorker") ||
                     MediaSource.canConstructInDedicatedWorker !== true)) {
    log(log_div, "Error: MediaSource API is unavailable from DedicatedWorker context.");
    decrement_pending_ended();
    return;
  }

  video.onerror = () => {
    log(log_div,
        "Video Element Error: code=" + video.error.code +
            ", message=" + video.error.message);
    if (!handled_decrement) {
      handled_decrement = true;
      decrement_pending_ended();
    }
    return;
  }

  video.onended = () => {
    log(log_div, "Video Element 'ended'");
    if (!handled_decrement) {
      handled_decrement = true;
      decrement_pending_ended();
    }
    return;
  }

  let player_promise;
  if (use_worker) {
    player_promise = start_mse_buffering_in_worker(log_div, video);
  } else {
    player_promise = start_mse_buffering_in_main(log_div, video);
  }

  player_promise.catch(e => {
    if (!handled_decrement) {
      handled_decrement = true;
      decrement_pending_ended();
    }
    log(log_div, e);
    return;
  });
}

// We use a button's onclick to start the demo to satisfy autoplay user gesture requirement.
function start_demo_players() {
  start_button.onclick="";
  start_button.style.backgroundColor = "gray";
  start_button.innerText="Starting";
  wait_div.innerText="";
  start_demo_player(main_div, false /* don't use_worker */);
  start_demo_player(worker_div, true   /* do use_worker */);
  start_button.innerText="Started";
}

</script>
</body>
